# Clarifications and Corrections for Chapter 3

* Page 52: In the code samples here and elsewhere, an `Iterable` class that aggregates a `List` implements methods `iterator()` by delegating the call to its aggregate: `return aCards.iterator()`. Strictly speaking, this idiom can violate the encapsulation of class `Deck` because interface `Iterator` includes a method `remove` than can be optionally implemented (and which *is* implemented by `ArrayList`). Consistent with the book's goal of focusing on general design concerns with minimum coverage of the libraries, I overlook this case. In the context of the book it can be assumed that `Iterator.remove()` is not used. For production code how to best avoid the encapsulation problem would depend on the properties of the context. One option is to return the iterator obtained from an unmodifiable view of the list, e.g., `return Collections.unmodifiableList(aCards).iterator()`.